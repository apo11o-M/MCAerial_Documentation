{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MCAerial Mod Documentation!! Overview This is the documentation for the MCAerial Mod, Minecraft, and Forge. You can find this MCAerial Documentation on GitHub. You can also find the MCAerial Mod at https://github.com/apo11o-M/MCAerial_Mod This documentation's intention is a note for myself as I learned & progress throughout minecraft modding, and it captures my best explanations and practices on those topics. I also posted some of the most helpful guides and tutorials I found throughout the internet in the end of this document. Be sure to check them out!!","title":"Home"},{"location":"#welcome-to-mcaerial-mod-documentation","text":"","title":"Welcome to MCAerial Mod Documentation!!"},{"location":"#overview","text":"This is the documentation for the MCAerial Mod, Minecraft, and Forge. You can find this MCAerial Documentation on GitHub. You can also find the MCAerial Mod at https://github.com/apo11o-M/MCAerial_Mod This documentation's intention is a note for myself as I learned & progress throughout minecraft modding, and it captures my best explanations and practices on those topics. I also posted some of the most helpful guides and tutorials I found throughout the internet in the end of this document. Be sure to check them out!!","title":"Overview"},{"location":"blocks/blocks/","text":"Blocks For simple blocks (think of cobblestone, dirt, grass, wood, etc.) which do not need any special functionality or attributes, a custom class is not necessary. It\u2019s also recommended to create a general block class for your mod for reasons mentioned above. If you want more functionality (such as interactions with players) then a custom class is required. The Block class has many methods that you can implement to your custom block class. Not-Full Blocks Sometimes we want to create blocks that are smaller and doesn't take the full-block space, such as half slabs or fences. To do so, we would have to declare a new object and override a few methods. First is to declare an AxisAlignedBB object like so: public static final AxisAlignedBB CUSTOM_BLOCK = new AxisAlignedBB(minX, minY, minZ, maxX, maxY, maxZ); . The object takes six arguments, the first three are the minimum coordinates (x, y, z) of the bounding box, and the last three are the maximum coordinates (x, y, z) of the bounding box. All of them are guaranteed to be less than 1 (if the argument is greater than 1 then it means the bounding box is bigger than a full block and weird things would happen). The second is to override the getBoundingBox() method to return the CUSTOM_BLOCK object we just created. And at last override the isFullBlock() method to return false. Transparent blocks So, how do we create transparent blocks? One way is to extend the minecraft BlockGlass class and call it done. Another way is to just override two methods, and we'll demonstrate that here. Override the isOpaqueCube() method and return false Override the getBlockLayer() method and return BlockRenderLayer.CUTOUT And that's it. The player will now be able to see the stuff behind the block through the part of the texture that's transparent . It's very important for you to not color the part of the texture where you want to see through, or else it won't work. ItemBlock Class ItemBlock is a subclass of Item and has a field block that holds a reference to the block it presents. A block with Block class but not ItemBlock class will be impossible to hold in inventory. (like minecraft:water exists as a block but can\u2019t hold in an inventory)","title":"Home"},{"location":"blocks/blocks/#blocks","text":"For simple blocks (think of cobblestone, dirt, grass, wood, etc.) which do not need any special functionality or attributes, a custom class is not necessary. It\u2019s also recommended to create a general block class for your mod for reasons mentioned above. If you want more functionality (such as interactions with players) then a custom class is required. The Block class has many methods that you can implement to your custom block class.","title":"Blocks"},{"location":"blocks/blocks/#not-full-blocks","text":"Sometimes we want to create blocks that are smaller and doesn't take the full-block space, such as half slabs or fences. To do so, we would have to declare a new object and override a few methods. First is to declare an AxisAlignedBB object like so: public static final AxisAlignedBB CUSTOM_BLOCK = new AxisAlignedBB(minX, minY, minZ, maxX, maxY, maxZ); . The object takes six arguments, the first three are the minimum coordinates (x, y, z) of the bounding box, and the last three are the maximum coordinates (x, y, z) of the bounding box. All of them are guaranteed to be less than 1 (if the argument is greater than 1 then it means the bounding box is bigger than a full block and weird things would happen). The second is to override the getBoundingBox() method to return the CUSTOM_BLOCK object we just created. And at last override the isFullBlock() method to return false.","title":"Not-Full Blocks"},{"location":"blocks/blocks/#transparent-blocks","text":"So, how do we create transparent blocks? One way is to extend the minecraft BlockGlass class and call it done. Another way is to just override two methods, and we'll demonstrate that here. Override the isOpaqueCube() method and return false Override the getBlockLayer() method and return BlockRenderLayer.CUTOUT And that's it. The player will now be able to see the stuff behind the block through the part of the texture that's transparent . It's very important for you to not color the part of the texture where you want to see through, or else it won't work.","title":"Transparent blocks"},{"location":"blocks/blocks/#itemblock-class","text":"ItemBlock is a subclass of Item and has a field block that holds a reference to the block it presents. A block with Block class but not ItemBlock class will be impossible to hold in inventory. (like minecraft:water exists as a block but can\u2019t hold in an inventory)","title":"ItemBlock Class"},{"location":"concepts/initialization/","text":"Initialization During startup, Forge will call your mod several times to add new blocks, items, read configuration files, and integrate itself into the game by registering your classes in the appropriate location. PreInitialization - Run before anything else. Read your config, create blocks, items, etc, and register them within the GameRegistry. Initialization - Do your mod setup. Build whatever data structures you care about, and register recipes. PostInitialization - Handle interactions with other mods. PreInitialization is performed for all the mods you installed, followed by Initialization for all mods, followed by PostInitialization for all mods. Initializing the mods in init() is particularly useful when there might be interactions between multiple mods","title":"Initialization"},{"location":"concepts/initialization/#initialization","text":"During startup, Forge will call your mod several times to add new blocks, items, read configuration files, and integrate itself into the game by registering your classes in the appropriate location. PreInitialization - Run before anything else. Read your config, create blocks, items, etc, and register them within the GameRegistry. Initialization - Do your mod setup. Build whatever data structures you care about, and register recipes. PostInitialization - Handle interactions with other mods. PreInitialization is performed for all the mods you installed, followed by Initialization for all mods, followed by PostInitialization for all mods. Initializing the mods in init() is particularly useful when there might be interactions between multiple mods","title":"Initialization"},{"location":"concepts/registry/","text":"Registry Handler Registration is the process of taking the objects of a mod (items, blocks, entities, sounds, etc.) and making them known to the game. Registering things is important, as without registration the game will simply not know about these objects in a mod and will exhibit great amounts of unexplainable behavior (and probably crash). The registry process happens in the Initialization stage during minecraft startup. More details can be found on the Forge Documentation","title":"Registries"},{"location":"concepts/registry/#registry-handler","text":"Registration is the process of taking the objects of a mod (items, blocks, entities, sounds, etc.) and making them known to the game. Registering things is important, as without registration the game will simply not know about these objects in a mod and will exhibit great amounts of unexplainable behavior (and probably crash). The registry process happens in the Initialization stage during minecraft startup. More details can be found on the Forge Documentation","title":"Registry Handler"},{"location":"concepts/sides/","text":"Sides The minecraft code can be divided into two \"sides\" - Client and Server - The Server side is responsible for running the game logic (mob spawning, weather, updating inventories, health, AI, etc), maintaining the master copy of the world - updating the blocks and entities based on packets received from the client, and sending updated information to all the clients. - The Client side is primarily responsible for reading input from the player and for rendering the screen. In a minecraft single player world, there is one server and one client both running in your computer. In multiplayer mode, there is one server but with multiple clients (players) connect to it. In order to distinguish between the client and server, you use the boolean check world.isRemote to check sides. If the field is true , the world is currently running on the logical client. If the field is false , then the world is running on the logical server. Now you may ask: why do we need to check the sides? It's because we have to ensure that the game logic and other mechanics only runs on the server side, such as damaging the player every time they walk on your block, or have your machine process dirt into diamonds. Applying game logic to the client side could cause desynchronization (ghost entities, desynchronized stats, disappearing items, etc) in the lightest case, and crashes in the worst case. GreyMinecraftCoder has an indepth explanation on this topic. The Client <--> Server Division","title":"Sides"},{"location":"concepts/sides/#sides","text":"The minecraft code can be divided into two \"sides\" - Client and Server - The Server side is responsible for running the game logic (mob spawning, weather, updating inventories, health, AI, etc), maintaining the master copy of the world - updating the blocks and entities based on packets received from the client, and sending updated information to all the clients. - The Client side is primarily responsible for reading input from the player and for rendering the screen. In a minecraft single player world, there is one server and one client both running in your computer. In multiplayer mode, there is one server but with multiple clients (players) connect to it. In order to distinguish between the client and server, you use the boolean check world.isRemote to check sides. If the field is true , the world is currently running on the logical client. If the field is false , then the world is running on the logical server.","title":"Sides"},{"location":"concepts/sides/#now-you-may-ask-why-do-we-need-to-check-the-sides","text":"It's because we have to ensure that the game logic and other mechanics only runs on the server side, such as damaging the player every time they walk on your block, or have your machine process dirt into diamonds. Applying game logic to the client side could cause desynchronization (ghost entities, desynchronized stats, disappearing items, etc) in the lightest case, and crashes in the worst case. GreyMinecraftCoder has an indepth explanation on this topic. The Client <--> Server Division","title":"Now you may ask: why do we need to check the sides?"},{"location":"entities/entities/","text":"Entities Entities are one of the most interesting concept in minecraft, and it's so broad, that this doc can't fit every single bit of info into it. So instead, I picked out some of the most important concepts in this class. motionX , motionY , motionZ - these three fields determines the motion/speed towards the corresponding axis. This is very useful for making vehicles such as cars or airplanes. rotationYaw , rotationPitch - the yaw and pitch rotation angle For rotationYaw , 0 degrees at north (Z axis, negative), clockwise is positive, counter-clockwise is negative. When the angle reach 360 degrees, minecraft will convert it into 0 degrees. So there will be no issues where rotationYaw gets bigger than 360 degrees. For rotationPitch , 0 degrees at horizontal, look down is positive, look up is negative. The range is from 180 to -180 degrees. rotationRoll - Minecraft does not have rotationRoll integrated into the game, so if one wants to create roll effect, you would have to done it by yourself by adding a few new variables to your entity class. Most of the time we use rotationRoll for rotating the model and the player's camera. Rotating the player's model can be done using the RenderPlayerEvent (see more in RenderPlayer ). As for rotating the player's camera, it can be done using the CameraSetup event which allows the mod to alter the angle of the player's camera in the yaw, pitch, and roll direction. ignoreFrustumCheck - Since minecraft only render entities whom bounding box are in the player's view, for those whose model significantly exceeds the bounding box, we can set ignoreFrustumCheck = true in the constructor so that minecraft will always render the entity's model.","title":"Home"},{"location":"entities/entities/#entities","text":"Entities are one of the most interesting concept in minecraft, and it's so broad, that this doc can't fit every single bit of info into it. So instead, I picked out some of the most important concepts in this class. motionX , motionY , motionZ - these three fields determines the motion/speed towards the corresponding axis. This is very useful for making vehicles such as cars or airplanes. rotationYaw , rotationPitch - the yaw and pitch rotation angle For rotationYaw , 0 degrees at north (Z axis, negative), clockwise is positive, counter-clockwise is negative. When the angle reach 360 degrees, minecraft will convert it into 0 degrees. So there will be no issues where rotationYaw gets bigger than 360 degrees. For rotationPitch , 0 degrees at horizontal, look down is positive, look up is negative. The range is from 180 to -180 degrees. rotationRoll - Minecraft does not have rotationRoll integrated into the game, so if one wants to create roll effect, you would have to done it by yourself by adding a few new variables to your entity class. Most of the time we use rotationRoll for rotating the model and the player's camera. Rotating the player's model can be done using the RenderPlayerEvent (see more in RenderPlayer ). As for rotating the player's camera, it can be done using the CameraSetup event which allows the mod to alter the angle of the player's camera in the yaw, pitch, and roll direction. ignoreFrustumCheck - Since minecraft only render entities whom bounding box are in the player's view, for those whose model significantly exceeds the bounding box, we can set ignoreFrustumCheck = true in the constructor so that minecraft will always render the entity's model.","title":"Entities"},{"location":"events/eventhandlers/","text":"EventHandlers Minecraft Forge provides event buses that are extremely useful for modders. The general concept is that you create \"event handling\" methods that subscribe a particular event, and being fired every time that event happens. Create an Event Handler General steps: Create am event handling class , you can name it whatever you want. Give your class the @EventBusSubscriber annotation . By doing this you don't need to actually register it, that will happen automatically! Put public static void [your_event_name](Event) methods in the your event handling class. Each method needs to have the @SubscribeEvent annotation and the parameter passed to the event must be the type of event you are trying to handle. The methods should contain your custom code to whatever you want when the event happens. Note: It is important to note that the event parameter passed usually has a number of useful fields and methods to aid your custom code. For more information see Jabelar's guide on Minecraft Event Handling Using Event Handling To Modify Vanilla Behavior For your own custom classes, you often don't need event handling because you already have the means of controlling their behavior. So event handling is most useful for the purpose of changing the behavior of \"vanilla\" blocks, items, entities, world generation, etc. Note: Before implementing event handling you should first check to see if there are already public methods and fields available to you. For example, changing a texture of a block or changing the motion of an entity can be done with public methods. Even though events could be used for these examples, it is probably easiest to use the provided methods. (Preferable To Not Use) Event Handling In Custom Classes If you make your own classes, especially as extending existing blocks, items or entities, you already have access to @Override several methods that are actually event handlers. Many of these methods are named starting with \"on\", like onUpdate() . These methods are automatically called at the same time as the related events are posted and so don't need to be called or otherwise handled. Event Cancelation It is especially important to understand is that certain events are \"cancelable\", which is usually annotated with @Cancelable . The cool thing about cancelable events is you can choose to prevent (i.e. cancel) the vanilla processing from happening at all: cancelable events allow you to fully replace the vanilla event handling with your own code! Warning : One problem with event cancelation is that it will affect other mods as well and can cause event incompatibility. You can affect the order of handling using priority (described below) and for those at the same priority I believe the handlers will fire based on the order the mods are loaded (or more specifically in order they register the handlers which is usually during the FMLInitializationEvent so would be in order they are loaded).","title":"EventHandlers"},{"location":"events/eventhandlers/#eventhandlers","text":"Minecraft Forge provides event buses that are extremely useful for modders. The general concept is that you create \"event handling\" methods that subscribe a particular event, and being fired every time that event happens.","title":"EventHandlers"},{"location":"events/eventhandlers/#create-an-event-handler","text":"General steps: Create am event handling class , you can name it whatever you want. Give your class the @EventBusSubscriber annotation . By doing this you don't need to actually register it, that will happen automatically! Put public static void [your_event_name](Event) methods in the your event handling class. Each method needs to have the @SubscribeEvent annotation and the parameter passed to the event must be the type of event you are trying to handle. The methods should contain your custom code to whatever you want when the event happens. Note: It is important to note that the event parameter passed usually has a number of useful fields and methods to aid your custom code. For more information see Jabelar's guide on Minecraft Event Handling","title":"Create an Event Handler"},{"location":"events/eventhandlers/#using-event-handling-to-modify-vanilla-behavior","text":"For your own custom classes, you often don't need event handling because you already have the means of controlling their behavior. So event handling is most useful for the purpose of changing the behavior of \"vanilla\" blocks, items, entities, world generation, etc. Note: Before implementing event handling you should first check to see if there are already public methods and fields available to you. For example, changing a texture of a block or changing the motion of an entity can be done with public methods. Even though events could be used for these examples, it is probably easiest to use the provided methods.","title":"Using Event Handling To Modify Vanilla Behavior"},{"location":"events/eventhandlers/#preferable-to-not-use-event-handling-in-custom-classes","text":"If you make your own classes, especially as extending existing blocks, items or entities, you already have access to @Override several methods that are actually event handlers. Many of these methods are named starting with \"on\", like onUpdate() . These methods are automatically called at the same time as the related events are posted and so don't need to be called or otherwise handled.","title":"(Preferable To Not Use) Event Handling In Custom Classes"},{"location":"events/eventhandlers/#event-cancelation","text":"It is especially important to understand is that certain events are \"cancelable\", which is usually annotated with @Cancelable . The cool thing about cancelable events is you can choose to prevent (i.e. cancel) the vanilla processing from happening at all: cancelable events allow you to fully replace the vanilla event handling with your own code! Warning : One problem with event cancelation is that it will affect other mods as well and can cause event incompatibility. You can affect the order of handling using priority (described below) and for those at the same priority I believe the handlers will fire based on the order the mods are loaded (or more specifically in order they register the handlers which is usually during the FMLInitializationEvent so would be in order they are loaded).","title":"Event Cancelation"},{"location":"exporting/exporting/","text":"Exporting your mod So you just finished building you mod, and the next step is to export it as .jar file that people can use. 1. Open you command prompt inside your mod folder 2. Run gradlew build , or bash gradlew build if you're running on macOS 3. Once the build is done, go to your mod folder > build > libs and there will be two files in there. The one with the word \"source\" is the source code of your mod. KEEP IT! It's the other one that you post online or share to others. For sharing your mod online, I suggest create an account and upload your file to Mediafire , and it will generate a link that anyone will be able to access and download. Common issues The command prompt shows \u201cBuild fail\u201d when you are trying to export your mod. * What went wrong: Execution failed for task ':processResources' This is due to an issue with forge 1.12.2 and your mcmod.info file. Change the mcversion from 1.12.2 to mcversion (...yeah) and it should fix the crash. \"mcversion\": \"${mcversion}\"","title":"Exporting"},{"location":"exporting/exporting/#exporting-your-mod","text":"So you just finished building you mod, and the next step is to export it as .jar file that people can use. 1. Open you command prompt inside your mod folder 2. Run gradlew build , or bash gradlew build if you're running on macOS 3. Once the build is done, go to your mod folder > build > libs and there will be two files in there. The one with the word \"source\" is the source code of your mod. KEEP IT! It's the other one that you post online or share to others. For sharing your mod online, I suggest create an account and upload your file to Mediafire , and it will generate a link that anyone will be able to access and download.","title":"Exporting your mod"},{"location":"exporting/exporting/#common-issues","text":"The command prompt shows \u201cBuild fail\u201d when you are trying to export your mod. * What went wrong: Execution failed for task ':processResources' This is due to an issue with forge 1.12.2 and your mcmod.info file. Change the mcversion from 1.12.2 to mcversion (...yeah) and it should fix the crash. \"mcversion\": \"${mcversion}\"","title":"Common issues"},{"location":"guides/guides/","text":"Very Helpful Guides/Links Here are some of the most helpful guides that I found throughout the internet. Be sure to check them out!! Forge Documentation (1.12.2) - The official Forge documentation for minecraft 1.12.2 version Jabelar's Minecraft Forge Modding Tutorials - Covered A LOT of topics in Minecraft modding. TheGreyGhost's Modding Guide - Similar to Jabelar's tutorials. TechnoVision Minecraft Modding Tutorials - Youtube tutorial, very helpful for beginners. Minecraft Modding by Bedrock_Miner - In depth guide that explains the concepts very well, but it's a bit outdated. Blockbench - My go-to 3D model editor for my blocks and entities. GIMP - A free & open-source graphic editor used for image editing. I used this software to make textures for the items and the gui.","title":"Guides"},{"location":"guides/guides/#very-helpful-guideslinks","text":"Here are some of the most helpful guides that I found throughout the internet. Be sure to check them out!! Forge Documentation (1.12.2) - The official Forge documentation for minecraft 1.12.2 version Jabelar's Minecraft Forge Modding Tutorials - Covered A LOT of topics in Minecraft modding. TheGreyGhost's Modding Guide - Similar to Jabelar's tutorials. TechnoVision Minecraft Modding Tutorials - Youtube tutorial, very helpful for beginners. Minecraft Modding by Bedrock_Miner - In depth guide that explains the concepts very well, but it's a bit outdated. Blockbench - My go-to 3D model editor for my blocks and entities. GIMP - A free & open-source graphic editor used for image editing. I used this software to make textures for the items and the gui.","title":"Very Helpful Guides/Links"},{"location":"guis/gettingstarted/","text":"Getting Started Making blocks with guis can be confusing because there are several things that have to work together. More importantly, you may not need all the complexity depending on what you are trying to achieve. Before you start, you should know what kind of classes you would/might have to implement. Do you need an IInventory This class holds the information about any stuffs (items or blocks) that are contained inside the block. For example when you put a stack of coal into the furnace it is going into the block's inventory. Do you need a Container If your block have an IInventory or a custom gui then Container class is a must. It helps combining the inventories and sync them between the client and the server. Do you need a GuiContainer This is where the actual \"gui stuff\" goes. This class handles the rendering of your custom gui textures, and handles the gui buttons on screen. If you are making a custom gui, you would most likely need this class. Do you need an IGuiHandler If you use a Container then IGuiHandler class is a must. It helps creating network packets to sync up the containers on the client and the server. The IGuiHandler also needs a unique GUI ID passed to it as a parameter, so I suggest creating an enum to help manage these IDs. Do you need a TileEntity A tile entity is like a variation of a regular block with IInventory. It is particularly useful if you want to gui to continue to do something even when it isn't open. For example a furnace will continue to cook something even if you are not in the gui. Examples where no tile entity is needed: A simple block that just displays some information in the GUI, like maybe a sign that displays your mod's credits or help info. A block where the processing happens instantaneously like a crafting table. Examples where a tile entity is recommended: A block where processing happens over time like cooking in a furnace.","title":"Getting Started"},{"location":"guis/gettingstarted/#getting-started","text":"Making blocks with guis can be confusing because there are several things that have to work together. More importantly, you may not need all the complexity depending on what you are trying to achieve. Before you start, you should know what kind of classes you would/might have to implement.","title":"Getting Started"},{"location":"guis/gettingstarted/#do-you-need-an-iinventory","text":"This class holds the information about any stuffs (items or blocks) that are contained inside the block. For example when you put a stack of coal into the furnace it is going into the block's inventory.","title":"Do you need an IInventory"},{"location":"guis/gettingstarted/#do-you-need-a-container","text":"If your block have an IInventory or a custom gui then Container class is a must. It helps combining the inventories and sync them between the client and the server.","title":"Do you need a Container"},{"location":"guis/gettingstarted/#do-you-need-a-guicontainer","text":"This is where the actual \"gui stuff\" goes. This class handles the rendering of your custom gui textures, and handles the gui buttons on screen. If you are making a custom gui, you would most likely need this class.","title":"Do you need a GuiContainer"},{"location":"guis/gettingstarted/#do-you-need-an-iguihandler","text":"If you use a Container then IGuiHandler class is a must. It helps creating network packets to sync up the containers on the client and the server. The IGuiHandler also needs a unique GUI ID passed to it as a parameter, so I suggest creating an enum to help manage these IDs.","title":"Do you need an IGuiHandler"},{"location":"guis/gettingstarted/#do-you-need-a-tileentity","text":"A tile entity is like a variation of a regular block with IInventory. It is particularly useful if you want to gui to continue to do something even when it isn't open. For example a furnace will continue to cook something even if you are not in the gui. Examples where no tile entity is needed: A simple block that just displays some information in the GUI, like maybe a sign that displays your mod's credits or help info. A block where the processing happens instantaneously like a crafting table. Examples where a tile entity is recommended: A block where processing happens over time like cooking in a furnace.","title":"Do you need a TileEntity"},{"location":"guis/implementingclasses/","text":"Implementing Classes IInventory This is fairly simple as we typically just need to extend the existing IInventory classes such as the InventoryCraftingResult or the InventoryEnderChest . The IInventory class is essentially a list that stores a bunch of ItemStacks and with many other helper methods that manipulates the list. Container As stated above, this is the class than handles the interactions between the player(client) and the server. In the constructor we creates Slots using the addSlotToContainer() method and link the slot to the block's and player's inventory. The slots are the translucent boxes you see when you hover your mouse over some of the container block's guis. It is capable to connect with both the player's and the block's inventory. Note that we also have to specify the on-screen position of the slot. One thing to note is the transferStackInSlot() method. It has to be implemented by the modders since the inherited method doesn't do anything. This method is called when the player wants to move an itemstack from one slot to another. This includes left clicks and shift-clicks. Failure to consider the possibilities would result in weird inventory behaviors such as itemstacks disappearing or even mc stuck in a infinite for loop. GuiContainer This class specifies the layout of the gui, render the background images, retrives items and progress bars for display, amd more. There are multiple gui drawing methods in the GUI class, and each of them have different usages and parameters. For my texture I am using the drawModalRectWithCustomSizedTexture() since my gui texture size is not the default 176x166 pixels. I also suggest using GNU Image Manipulation Program (GIMP) or Adobe Photoshop to create your gui textures. You can also go into minecraft's source code, find the original png textures and start from there. It would save you tons of time if you have a template to start with. To find the original png textures from minecraft, go to your minecraft folder -> versions folder -> 1.12.2 folder -> 1.12.2.jar , extract the .jar file into a folder, open the folder and go to assets -> minecraft -> textures -> container and you will find the gui textures there. To add buttons to the gui, we have to initialize it in the initGui() method, create an if block with the button's id, and perform the actions for each buttons. It's also important to not offset the textures and buttons by absolute pixels, but rather use proportions based on the screen size. This is because each person has different monitor/screen sizes and different UI size settings. If we uses absolute pixels to offset their position it's very easy to mess up the entire layout for a different window size setting. Note: This class only runs on the CLIENT SIDE , so if you want to do stuff that would relate to the server side such as adding items into certain slots, you would have to send a packet to the server side and add the item over there or else your gui would have desyncing issues. I have an example of setting up packets and IMessages in Networking . IGuiHandler The IGuiHandler provides the Synchronization of the slot contents between the server and client and lets you avoid having to create custom packets. Basically it provides an association between the Container on the server side and the GuiScreen on the client side. The class check the enumerated ID that is passed into the methods and return the associated element (Container on the server side, or GuiScreen on the client side).","title":"Implementing Classes"},{"location":"guis/implementingclasses/#implementing-classes","text":"","title":"Implementing Classes"},{"location":"guis/implementingclasses/#iinventory","text":"This is fairly simple as we typically just need to extend the existing IInventory classes such as the InventoryCraftingResult or the InventoryEnderChest . The IInventory class is essentially a list that stores a bunch of ItemStacks and with many other helper methods that manipulates the list.","title":"IInventory"},{"location":"guis/implementingclasses/#container","text":"As stated above, this is the class than handles the interactions between the player(client) and the server. In the constructor we creates Slots using the addSlotToContainer() method and link the slot to the block's and player's inventory. The slots are the translucent boxes you see when you hover your mouse over some of the container block's guis. It is capable to connect with both the player's and the block's inventory. Note that we also have to specify the on-screen position of the slot. One thing to note is the transferStackInSlot() method. It has to be implemented by the modders since the inherited method doesn't do anything. This method is called when the player wants to move an itemstack from one slot to another. This includes left clicks and shift-clicks. Failure to consider the possibilities would result in weird inventory behaviors such as itemstacks disappearing or even mc stuck in a infinite for loop.","title":"Container"},{"location":"guis/implementingclasses/#guicontainer","text":"This class specifies the layout of the gui, render the background images, retrives items and progress bars for display, amd more. There are multiple gui drawing methods in the GUI class, and each of them have different usages and parameters. For my texture I am using the drawModalRectWithCustomSizedTexture() since my gui texture size is not the default 176x166 pixels. I also suggest using GNU Image Manipulation Program (GIMP) or Adobe Photoshop to create your gui textures. You can also go into minecraft's source code, find the original png textures and start from there. It would save you tons of time if you have a template to start with. To find the original png textures from minecraft, go to your minecraft folder -> versions folder -> 1.12.2 folder -> 1.12.2.jar , extract the .jar file into a folder, open the folder and go to assets -> minecraft -> textures -> container and you will find the gui textures there. To add buttons to the gui, we have to initialize it in the initGui() method, create an if block with the button's id, and perform the actions for each buttons. It's also important to not offset the textures and buttons by absolute pixels, but rather use proportions based on the screen size. This is because each person has different monitor/screen sizes and different UI size settings. If we uses absolute pixels to offset their position it's very easy to mess up the entire layout for a different window size setting. Note: This class only runs on the CLIENT SIDE , so if you want to do stuff that would relate to the server side such as adding items into certain slots, you would have to send a packet to the server side and add the item over there or else your gui would have desyncing issues. I have an example of setting up packets and IMessages in Networking .","title":"GuiContainer"},{"location":"guis/implementingclasses/#iguihandler","text":"The IGuiHandler provides the Synchronization of the slot contents between the server and client and lets you avoid having to create custom packets. Basically it provides an association between the Container on the server side and the GuiScreen on the client side. The class check the enumerated ID that is passed into the methods and return the associated element (Container on the server side, or GuiScreen on the client side).","title":"IGuiHandler"},{"location":"items/items/","text":"Items Basic items that do not need and special functionality or attributes do not need a custom class. It\u2019s also recommended to create your mod\u2019s general item class since you can put all your custom items and blocks into a dedicated tab in creative mode. Holding the Item Right Click Sometimes we want to make something happen when the player is holding the item and right clicks on a block. To do so, we override the method onItemUse() which is called when the player right clicks the item on a block. In the MCAerial_Mod, I make the item spawn a glider on a block when it's being right clicked by using worldIn.spawnEntity(new EntityPlane(worldIn, (double)pos.getX() + 0.5, (double)pos.getY() + 1, (double)pos.getZ() + 0.5)); . Note: Be sure to check the sides! Spawning entities should only happen on the server side or ghost entities would happen. Common issue(s) You implemented the recipes but nothing shows up when you\u2019re in the game. It\u2019s possible that you did not specify the state of the blocks you're using (this mostly happens with stone, dirt, or colored wool as those blocks have different states). Simply add \"data\": 0 to the end of the block id to and it should fix the issue. \"item\": \"minecraft:stone\", \"data\": 0","title":"Home"},{"location":"items/items/#items","text":"Basic items that do not need and special functionality or attributes do not need a custom class. It\u2019s also recommended to create your mod\u2019s general item class since you can put all your custom items and blocks into a dedicated tab in creative mode.","title":"Items"},{"location":"items/items/#holding-the-item-right-click","text":"Sometimes we want to make something happen when the player is holding the item and right clicks on a block. To do so, we override the method onItemUse() which is called when the player right clicks the item on a block. In the MCAerial_Mod, I make the item spawn a glider on a block when it's being right clicked by using worldIn.spawnEntity(new EntityPlane(worldIn, (double)pos.getX() + 0.5, (double)pos.getY() + 1, (double)pos.getZ() + 0.5)); . Note: Be sure to check the sides! Spawning entities should only happen on the server side or ghost entities would happen.","title":"Holding the Item Right Click"},{"location":"items/items/#common-issues","text":"You implemented the recipes but nothing shows up when you\u2019re in the game. It\u2019s possible that you did not specify the state of the blocks you're using (this mostly happens with stone, dirt, or colored wool as those blocks have different states). Simply add \"data\": 0 to the end of the block id to and it should fix the issue. \"item\": \"minecraft:stone\", \"data\": 0","title":"Common issue(s)"},{"location":"networking/concepts/","text":"Concepts The client and server are always connected by a network connection(packets). There are two primarily reasons for networking communication. Making sure the client view is \u201cin sync\u201d with the server view The flower at coordinates x, y, z, just grew. Giving the client a way to tell the server that something has changed about the player The player just pressed a key. The most common way to accomplish these goals is through the packet system where the client and the server send messages to each other. Those messages are usually structured, containing data in a particular arrangement, for the ease of sending and receiving. The simplest packet system would be Simplelmpl .","title":"Concepts"},{"location":"networking/concepts/#concepts","text":"The client and server are always connected by a network connection(packets). There are two primarily reasons for networking communication. Making sure the client view is \u201cin sync\u201d with the server view The flower at coordinates x, y, z, just grew. Giving the client a way to tell the server that something has changed about the player The player just pressed a key. The most common way to accomplish these goals is through the packet system where the client and the server send messages to each other. Those messages are usually structured, containing data in a particular arrangement, for the ease of sending and receiving. The simplest packet system would be Simplelmpl .","title":"Concepts"},{"location":"networking/simplelmpl/","text":"Simplelmpl (Packet System) The client and server are always connected by a network connection(packets). Simplelmpl is the name of the packet system we will be using. It's the easiest way to send custom data between the server and the client. PacketHandler Class The first step is to create the PacketHandler class. And inside the class we declare a SimpleNetworkWrapper object as a static field. public class PacketHandler { public static final SimpleNetworkWrapper INSTANCE = NetworkRegistry.INSTANCE.newSimpleChannel(\"yourModId\".toUpperCase()); private static int nextPacketId = 0; public static void initPackets() { registerMessage(MyMessage.class, MyMessage.MyPacket.class); } private static void registerMessage(Class message, Class packet) { INSTANCE.registerMessage(packet, message, nextPacketId, Side.CLIENT); INSTANCE.registerMessage(packet, message, nextPacketId, Side.SERVER); nextPacketId++; } } Notice that we also registered our classes using the registerMessage method. The initPackets method is being called during the init stage. To register our packet, simply call INSTANCE.registerMessage(MyMessageHandler.class, MyMessage.class, 0, Side.Server); Let's breakdown the parameters of this method. The first parameter messagehandler is the class that handles your packet. Note that this class must always have a default constructor . The second parameter requestMessageType is your actual packet class. Note that This class must also have a default constructor . The third parameter id is the discriminator for the packet. This is a per-channel unique ID for the packet. The final parameter side is the side that your packet will received on. If you are planning to send the packet on both sides, then the packet have to be registered twice, once on each side. IMessages (Packets) Now the next step is to create the packet itself. A packet is defined by using the IMessage interface. This interface defines 2 methods, toBytes and fromBytes . These methods, respectively, write and read the data in your packet to and from a ByteBuf object, which is an object used to hold a stream (array) of bytes which are sent through the network. Here's an example packet that's designed to send an int and a boolean through the network. public class MyMessage implements IMessage { private int simpleInt; private boolean simpleBool; // a default constructor that's always required otherwise you'll get errors public MyMessage() {} public MyMessage(int simpleInt, boolean simpleBool) { this.simpleInt = simpleInt; this.simpleBool = simpleBool; } @Override public void fromBytes(ByteBuf buf) { // reads the int back from the buf. Note if you have multiple values, you must read in the same order you wrote. this.simpleInt = buf.getInt(0); this.SimpleBool = buf.getBoolean(1); } @Override public void toBytes(ByteBuf buf) { // writes the int into the buf buf.writeInt(this.simpleInt); buf.writeBoolean(this.simpleBool); } } IMessageHandler Now, how do we use the packet? Well, first we have to have a class that handles the packet. This is created with the IMessageHandler interface. It's recommended to make the IMessageHandler class inside the IMessage class. Note that if this is done, the inner class has to be declared as static . In this example we want to give a certain amount of diamonds to the player based on the int we received. public static class MyIMessageHandler implements IMessageHandler<MyMessage, IMessage> { public MyPacket() {} // do whatever stuff you want based on the parameters you recieved // in this case I'm using the forge's documentation example, giving the player some diamonds @Override public IMessage onMessage(MyMessage message, MessageContext ctx) { // This is the player the packet was sent to the server from EntityPlayerMP serverPlayer = ctx.getServerHandler().player; // the value that was sent int amount = message.toSend; // Execute the action on the main server thread by adding it as a scheduled task Minecraft.getMinecraft().addScheduledTask(() -> { serverPlayer.inventory.addItemStackToInventory(new ItemStack(Items.DIAMOND, amount)); }); // no response packet return null; } } okay, so now how do we use the packets? Sending to the Server There is only one way to send packets to server, since there will only be one server to send to. To do so, simply call PacketHandler.INSTANCE.sendToServer(new MyMessage(toSend)) . The message will then be sent to the Side.SERVER IMessageHandler for its type. Sending to the Client There are four ways of sending packets to clients: sendToAll - This will send the packet to every single player on the server. No matter what location or dimension they are in. sendToDimension - This method takes two arguments: IMessage , and an int. The dimension int can be obtained through world.provider.getDimension() . The packet will be sent to all players in that dimension. sendToAllAround - This method takes the IMessage and NetworkRegistry.TargetPoint object. All players within the TargetPoint will have the packet be sent to them. A TargetPoint object requires a dimension, x/y/z coordinates, and a range. It represents a sphere with radius of range, centered at (x, y, z) in a world. sendTo - This send the packet to the specific player. Note that the player object has to be casted into EntityPlayerMP . sendToAllTracking - Last but not least, there is also INSTANCE.sendToAllTracking which sends packets to all players on the server who are \u201ctracking\u201d the target. There are two variants of sendToAllTracking : one accepts a TargetPoint , and another one accepts an Entity . For the former, all clients that has the block located at TargetPoint loaded will receive the packet; for the latter, all clients that are within the tracking range of supplied Entity will receive the packet. Do note that EntityPlayers will not track themselves, so this cannot replace the use of sendTo ; if the EntityPlayer that is used as target also requires syncing, you need to call sendTo on that before calling the Entity version of sendToAllTracking . Example So basically the result networking stuff would look something like this.","title":"Simplelmpl (Packets)"},{"location":"networking/simplelmpl/#simplelmpl-packet-system","text":"The client and server are always connected by a network connection(packets). Simplelmpl is the name of the packet system we will be using. It's the easiest way to send custom data between the server and the client.","title":"Simplelmpl (Packet System)"},{"location":"networking/simplelmpl/#packethandler-class","text":"The first step is to create the PacketHandler class. And inside the class we declare a SimpleNetworkWrapper object as a static field. public class PacketHandler { public static final SimpleNetworkWrapper INSTANCE = NetworkRegistry.INSTANCE.newSimpleChannel(\"yourModId\".toUpperCase()); private static int nextPacketId = 0; public static void initPackets() { registerMessage(MyMessage.class, MyMessage.MyPacket.class); } private static void registerMessage(Class message, Class packet) { INSTANCE.registerMessage(packet, message, nextPacketId, Side.CLIENT); INSTANCE.registerMessage(packet, message, nextPacketId, Side.SERVER); nextPacketId++; } } Notice that we also registered our classes using the registerMessage method. The initPackets method is being called during the init stage. To register our packet, simply call INSTANCE.registerMessage(MyMessageHandler.class, MyMessage.class, 0, Side.Server); Let's breakdown the parameters of this method. The first parameter messagehandler is the class that handles your packet. Note that this class must always have a default constructor . The second parameter requestMessageType is your actual packet class. Note that This class must also have a default constructor . The third parameter id is the discriminator for the packet. This is a per-channel unique ID for the packet. The final parameter side is the side that your packet will received on. If you are planning to send the packet on both sides, then the packet have to be registered twice, once on each side.","title":"PacketHandler Class"},{"location":"networking/simplelmpl/#imessages-packets","text":"Now the next step is to create the packet itself. A packet is defined by using the IMessage interface. This interface defines 2 methods, toBytes and fromBytes . These methods, respectively, write and read the data in your packet to and from a ByteBuf object, which is an object used to hold a stream (array) of bytes which are sent through the network. Here's an example packet that's designed to send an int and a boolean through the network. public class MyMessage implements IMessage { private int simpleInt; private boolean simpleBool; // a default constructor that's always required otherwise you'll get errors public MyMessage() {} public MyMessage(int simpleInt, boolean simpleBool) { this.simpleInt = simpleInt; this.simpleBool = simpleBool; } @Override public void fromBytes(ByteBuf buf) { // reads the int back from the buf. Note if you have multiple values, you must read in the same order you wrote. this.simpleInt = buf.getInt(0); this.SimpleBool = buf.getBoolean(1); } @Override public void toBytes(ByteBuf buf) { // writes the int into the buf buf.writeInt(this.simpleInt); buf.writeBoolean(this.simpleBool); } }","title":"IMessages (Packets)"},{"location":"networking/simplelmpl/#imessagehandler","text":"Now, how do we use the packet? Well, first we have to have a class that handles the packet. This is created with the IMessageHandler interface. It's recommended to make the IMessageHandler class inside the IMessage class. Note that if this is done, the inner class has to be declared as static . In this example we want to give a certain amount of diamonds to the player based on the int we received. public static class MyIMessageHandler implements IMessageHandler<MyMessage, IMessage> { public MyPacket() {} // do whatever stuff you want based on the parameters you recieved // in this case I'm using the forge's documentation example, giving the player some diamonds @Override public IMessage onMessage(MyMessage message, MessageContext ctx) { // This is the player the packet was sent to the server from EntityPlayerMP serverPlayer = ctx.getServerHandler().player; // the value that was sent int amount = message.toSend; // Execute the action on the main server thread by adding it as a scheduled task Minecraft.getMinecraft().addScheduledTask(() -> { serverPlayer.inventory.addItemStackToInventory(new ItemStack(Items.DIAMOND, amount)); }); // no response packet return null; } }","title":"IMessageHandler"},{"location":"networking/simplelmpl/#okay-so-now-how-do-we-use-the-packets","text":"","title":"okay, so now how do we use the packets?"},{"location":"networking/simplelmpl/#sending-to-the-server","text":"There is only one way to send packets to server, since there will only be one server to send to. To do so, simply call PacketHandler.INSTANCE.sendToServer(new MyMessage(toSend)) . The message will then be sent to the Side.SERVER IMessageHandler for its type.","title":"Sending to the Server"},{"location":"networking/simplelmpl/#sending-to-the-client","text":"There are four ways of sending packets to clients: sendToAll - This will send the packet to every single player on the server. No matter what location or dimension they are in. sendToDimension - This method takes two arguments: IMessage , and an int. The dimension int can be obtained through world.provider.getDimension() . The packet will be sent to all players in that dimension. sendToAllAround - This method takes the IMessage and NetworkRegistry.TargetPoint object. All players within the TargetPoint will have the packet be sent to them. A TargetPoint object requires a dimension, x/y/z coordinates, and a range. It represents a sphere with radius of range, centered at (x, y, z) in a world. sendTo - This send the packet to the specific player. Note that the player object has to be casted into EntityPlayerMP . sendToAllTracking - Last but not least, there is also INSTANCE.sendToAllTracking which sends packets to all players on the server who are \u201ctracking\u201d the target. There are two variants of sendToAllTracking : one accepts a TargetPoint , and another one accepts an Entity . For the former, all clients that has the block located at TargetPoint loaded will receive the packet; for the latter, all clients that are within the tracking range of supplied Entity will receive the packet. Do note that EntityPlayers will not track themselves, so this cannot replace the use of sendTo ; if the EntityPlayer that is used as target also requires syncing, you need to call sendTo on that before calling the Entity version of sendToAllTracking .","title":"Sending to the Client"},{"location":"networking/simplelmpl/#example","text":"So basically the result networking stuff would look something like this.","title":"Example"},{"location":"rendering/gettingstarted/","text":"Getting Started There are three basic parts in rendering entities onto the screen: The render class, the model , and the texture . The render class tells the computer how to render and do transformations on the model. The model is the object's 3D shape, and the texture is, well, the texture of the model.","title":"Getting Started"},{"location":"rendering/gettingstarted/#getting-started","text":"There are three basic parts in rendering entities onto the screen: The render class, the model , and the texture . The render class tells the computer how to render and do transformations on the model. The model is the object's 3D shape, and the texture is, well, the texture of the model.","title":"Getting Started"},{"location":"rendering/models/","text":"Model Files (.java & .obj files) A model is simply, a 3D shape that defines the outline of the object. There are a lot of model file formats out there, and the one that you see the most common in minecraft are .json, .java, and .obj file types. Blockbench Blockbench is a simple yet powerful 3D modeling program designed specifically for minecraft modding. I highly suggest using this program to make your own models if you haven't have experience in other types of 3D modeling softwares. JSON Models JSON files are the most common and the most simple 3D model format you see in minecraft. This file type defines the model for all the blocks and items in vanilla minecraft. It also specifies all the stuff about this model such as the offsets, rotations, and scales in many different sceneraios. Such as when the player is holding in right hand, when it's being rendered in the inventory, when it's being dropped onto the ground, etc. I suggest downloading the JSON Editor Plugin from Eclipse marketplace. The plugin will highlight your syntax errors in the json files. Otherwise it will be like editing a plain text file with no highlights which is a pain to troubleshoot. Java Models Java models are specifically for entity models. It's made using Blockbench. Note: be sure to group your cubes and rename them when you are working on the model in Blockbench or else they won't show up in minecraft!!","title":"Models"},{"location":"rendering/models/#model-files-java-obj-files","text":"A model is simply, a 3D shape that defines the outline of the object. There are a lot of model file formats out there, and the one that you see the most common in minecraft are .json, .java, and .obj file types.","title":"Model Files (.java &amp; .obj files)"},{"location":"rendering/models/#blockbench","text":"Blockbench is a simple yet powerful 3D modeling program designed specifically for minecraft modding. I highly suggest using this program to make your own models if you haven't have experience in other types of 3D modeling softwares.","title":"Blockbench"},{"location":"rendering/models/#json-models","text":"JSON files are the most common and the most simple 3D model format you see in minecraft. This file type defines the model for all the blocks and items in vanilla minecraft. It also specifies all the stuff about this model such as the offsets, rotations, and scales in many different sceneraios. Such as when the player is holding in right hand, when it's being rendered in the inventory, when it's being dropped onto the ground, etc. I suggest downloading the JSON Editor Plugin from Eclipse marketplace. The plugin will highlight your syntax errors in the json files. Otherwise it will be like editing a plain text file with no highlights which is a pain to troubleshoot.","title":"JSON Models"},{"location":"rendering/models/#java-models","text":"Java models are specifically for entity models. It's made using Blockbench. Note: be sure to group your cubes and rename them when you are working on the model in Blockbench or else they won't show up in minecraft!!","title":"Java Models"},{"location":"rendering/partialticks/","text":"Partial Ticks >> Partial ticks is a fractional value representing the amount of time that has passed since the last tick. Another important concept about rendering is partial ticks. Minecraft updates it's game logic every ticks, or 0.05 seconds, but the rendering class updates every frame, which is about 60fps for a normal computer. Now if we only change the rotation for the model every 0.05 seconds then it will have an unpleasant stuttering/choppy rotation. (The reason it rotates every 0.05 seconds is because we are using the rotation angle from our custom entity class, which, only updates every ticks). To fix this, we have to interpolate the rotating angle between the first frame and the second frame and rotate the model by that amount as the doRender() method is called upon every frame in minecraft. So here's the basic formula on how to calculate the rotation angle using partial ticks: >> prevAngle + (angle - prevAngle) x partialTicks","title":"Partial Ticks"},{"location":"rendering/partialticks/#partial-ticks","text":">> Partial ticks is a fractional value representing the amount of time that has passed since the last tick. Another important concept about rendering is partial ticks. Minecraft updates it's game logic every ticks, or 0.05 seconds, but the rendering class updates every frame, which is about 60fps for a normal computer. Now if we only change the rotation for the model every 0.05 seconds then it will have an unpleasant stuttering/choppy rotation. (The reason it rotates every 0.05 seconds is because we are using the rotation angle from our custom entity class, which, only updates every ticks). To fix this, we have to interpolate the rotating angle between the first frame and the second frame and rotate the model by that amount as the doRender() method is called upon every frame in minecraft. So here's the basic formula on how to calculate the rotation angle using partial ticks: >> prevAngle + (angle - prevAngle) x partialTicks","title":"Partial Ticks"},{"location":"rendering/renderclass/","text":"Render Class The purpose of the rendering class is to render the model and the texture of the entity. The doRender method is mainly responsible for that. The steps of properly render the entity is to: GlStateManager.pushMatrix - This is required before we use other OpenGL functions. Fail to do so would result in GLStackOverflow error. interpolateRotation() - interpolate the angle the model should rotate. See more on Partial Ticks . GlStateManager.translate(x, y, z) - Translate the entity's position. The arguments are the current x, y, and z coordinates plus the offsets you want to make. GlStateManager.rotate(angle, xAxis, yAxis, zAxis) - rotate the model about a specific axis. The angle is in degrees, and the x , y , and z field indicates which axis the model rotates. Ex. GlStatemanager.rotate(90F, 0.0F, 1.0F, 0.0F) means rotate 90 degrees clockwise about the y axis. bindTexture(ResourceLocation) - Bind the model with your texture. mainModel.render() - this sets the models various rotation angles then renders the model. GlStateManager.popMatrix - pop the matrix. Fail to do so would result in GLStackUnderflow error. Bedrock_Miner has a detailed guide on using GlStateManager class, be sure to check it out! Advanced Modding - Rendering RenderPlayer The pivot point of the player's model is located in the center of the feet, and if one want to change the pivot point, translate the model first, do the rotation, and then translate back. The player model dimension can be found on this thread. How Tall is Steve One thing to note is that when the program run GlStateManager.pushMatrix() in your RenderPlayerEvent.Pre event, all of the \"virtual\" axis minecraft did previously will be reseted ( Euler Angle Explained ), so if we want to rotate the player's model in the pitch and roll direction, we will have to rotate the model in the corresponding yaw angle first, do the pitch and roll, and then undo the yaw rotation we did by rotating in the reverse direction. Also, be sure to have a variable that indicates the program to pop the matrix in the RenderPlayerEvent.Post event. Popping the matrix in the RenderPlayerEvent.Pre event will cause GLStackUnderflow error. So the entire player model rotation process in the RenderPlayerEvent.Pre event looks like this: pushMatrix rotate in the yaw direction for the virtual axis translate the model to its pivot point do your pitch & roll rotation translate the model back undo step two by applying the same rotation but in opposite direction","title":"Render Class"},{"location":"rendering/renderclass/#render-class","text":"The purpose of the rendering class is to render the model and the texture of the entity. The doRender method is mainly responsible for that. The steps of properly render the entity is to: GlStateManager.pushMatrix - This is required before we use other OpenGL functions. Fail to do so would result in GLStackOverflow error. interpolateRotation() - interpolate the angle the model should rotate. See more on Partial Ticks . GlStateManager.translate(x, y, z) - Translate the entity's position. The arguments are the current x, y, and z coordinates plus the offsets you want to make. GlStateManager.rotate(angle, xAxis, yAxis, zAxis) - rotate the model about a specific axis. The angle is in degrees, and the x , y , and z field indicates which axis the model rotates. Ex. GlStatemanager.rotate(90F, 0.0F, 1.0F, 0.0F) means rotate 90 degrees clockwise about the y axis. bindTexture(ResourceLocation) - Bind the model with your texture. mainModel.render() - this sets the models various rotation angles then renders the model. GlStateManager.popMatrix - pop the matrix. Fail to do so would result in GLStackUnderflow error. Bedrock_Miner has a detailed guide on using GlStateManager class, be sure to check it out! Advanced Modding - Rendering","title":"Render Class"},{"location":"rendering/renderclass/#renderplayer","text":"The pivot point of the player's model is located in the center of the feet, and if one want to change the pivot point, translate the model first, do the rotation, and then translate back. The player model dimension can be found on this thread. How Tall is Steve One thing to note is that when the program run GlStateManager.pushMatrix() in your RenderPlayerEvent.Pre event, all of the \"virtual\" axis minecraft did previously will be reseted ( Euler Angle Explained ), so if we want to rotate the player's model in the pitch and roll direction, we will have to rotate the model in the corresponding yaw angle first, do the pitch and roll, and then undo the yaw rotation we did by rotating in the reverse direction. Also, be sure to have a variable that indicates the program to pop the matrix in the RenderPlayerEvent.Post event. Popping the matrix in the RenderPlayerEvent.Pre event will cause GLStackUnderflow error. So the entire player model rotation process in the RenderPlayerEvent.Pre event looks like this: pushMatrix rotate in the yaw direction for the virtual axis translate the model to its pivot point do your pitch & roll rotation translate the model back undo step two by applying the same rotation but in opposite direction","title":"RenderPlayer"},{"location":"rendering/textures/","text":"Textures (.png files) The texture size must be a square and a power of 2, such as 16x16, 32x32, 64x64 etc. Also, for entities be sure to add the textures location to the render class so minecraft knows where your texture are. Blockbench Blockbench also suppports making blocks and entities. Once you are finish making your model, export your project to .java models and a .png texture. GIMP The GNU Image Manipulation Program (GIMP) is a very powerful free image editor that can even compete with photoshop. Be sure to check it out!! Common issues: If one of the textures is broken, look at the json file. 90% of times a broken texture is because of a faulty json file. If the texture works in the inventory but not on the ground, check the spelling and run the json validator on the json file in assets.[youmodname].models.block . If the texture works when placed but not in the inventory, check the spelling and run the json validator on the json file in assets.[yourmodname].models.item . If the texture doesn\u2019t work at all, check the spelling and run the json validator on the json file in assets.[yourmodname].blockstates . If the texture still doesn\u2019t work at all, check your image file, make sure it\u2019s in png format and square size","title":"Textures"},{"location":"rendering/textures/#textures-png-files","text":"The texture size must be a square and a power of 2, such as 16x16, 32x32, 64x64 etc. Also, for entities be sure to add the textures location to the render class so minecraft knows where your texture are.","title":"Textures (.png files)"},{"location":"rendering/textures/#blockbench","text":"Blockbench also suppports making blocks and entities. Once you are finish making your model, export your project to .java models and a .png texture.","title":"Blockbench"},{"location":"rendering/textures/#gimp","text":"The GNU Image Manipulation Program (GIMP) is a very powerful free image editor that can even compete with photoshop. Be sure to check it out!!","title":"GIMP"},{"location":"rendering/textures/#common-issues","text":"If one of the textures is broken, look at the json file. 90% of times a broken texture is because of a faulty json file. If the texture works in the inventory but not on the ground, check the spelling and run the json validator on the json file in assets.[youmodname].models.block . If the texture works when placed but not in the inventory, check the spelling and run the json validator on the json file in assets.[yourmodname].models.item . If the texture doesn\u2019t work at all, check the spelling and run the json validator on the json file in assets.[yourmodname].blockstates . If the texture still doesn\u2019t work at all, check your image file, make sure it\u2019s in png format and square size","title":"Common issues:"}]}